/**
 * This code was generated by "react-native codegen-lib-harmony"
 */
#include "RNOH/ArkTSTurboModule.h"
#include "RNOH/RNInstance.h"
#include "RNWMDatabaseJSIBridge.h"
#include <string>
#include <map>
#include <memory>
#include <database/rdb/relational_store.h>
#include <database/rdb/oh_predicates.h>
#include <database/rdb/oh_values_bucket.h>
#include <database/rdb/oh_cursor.h>
#include <database/rdb/relational_store_error_code.h>
#include <database/udmf/udmf.h>
#include <database/rdb/oh_rdb_transaction.h>
#include <database/data/oh_data_values.h>
#include <nlohmann/json.hpp>

using namespace rnoh;
using namespace facebook;

static OH_Rdb_Store *globalStore = nullptr;
static std::mutex storeMutex;
static bool isDatabaseInitialized = false;

static jsi::Value hostFunction_MyTMTurboModule_install(jsi::Runtime &rt, react::TurboModule &turboModule,
                                                       const jsi::Value *args, size_t count)
{
    auto self = static_cast<RNWMDatabaseJSIBridge *>(&turboModule);
    self->JSIInstall(rt);
    std::string myString = "aaabbb";
    DLOG(ERROR) << "123456789 正在调用 myInstall 函数";
    return jsi::String::createFromUtf8(rt, myString);
}

RNWMDatabaseJSIBridge::RNWMDatabaseJSIBridge(const RNWMDatabaseJSIBridge::Context ctx, const std::string name) : WMDatabaseJSIBridge(ctx, name)
{
    methodMap_["myInstall"] = MethodMetadata{0, hostFunction_MyTMTurboModule_install};
}

void RNWMDatabaseJSIBridge::JSIInstall(facebook::jsi::Runtime &rt)
{
    DLOG(ERROR) << "123456789 JSI初始化开始";

    // 1. 获取全局对象
    auto globalObject = rt.global();

    // 2. 创建nativeWatermelonCreateAdapter函数
    auto createAdapterFunc = jsi::Function::createFromHostFunction(
        rt,
        jsi::PropNameID::forAscii(rt, "nativeWatermelonCreateAdapter"),
        2, // 参数数量：dbPath, usesExclusiveLocking
        [](jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args, size_t count) -> jsi::Value
        {
            if (count < 2)
            {
                throw jsi::JSError(rt, "nativeWatermelonCreateAdapter requires 2 arguments");
            }

            std::string dbPath = args[0].getString(rt).utf8(rt);
            bool usesExclusiveLocking = args[1].getBool();

            // 创建适配器对象
            jsi::Object adapter(rt);

            // 1. initialize方法
            auto initializeFunc = jsi::Function::createFromHostFunction(
                rt,
                jsi::PropNameID::forAscii(rt, "initialize"),
                2,
                [](jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args, size_t count) -> jsi::Value
                {
                    if (count < 2)
                    {
                        throw jsi::JSError(rt, "initialize requires 2 arguments");
                    }

                    // 提取参数
                    std::string dbName = args[0].getString(rt).utf8(rt);
                    int expectedVersion = (int)args[1].getNumber();

                    DLOG(ERROR) << "123456789 初始化调用 - 数据库名: " << dbName << ", 版本: " << expectedVersion;

                    std::lock_guard<std::mutex> lock(storeMutex);

                    // 如果已经初始化过，直接返回成功
                    if (isDatabaseInitialized && globalStore != nullptr)
                    {
                        DLOG(ERROR) << "123456789 数据库已经初始化，直接返回";

                        jsi::Object response(rt);
                        response.setProperty(rt, "code", jsi::String::createFromUtf8(rt, "ok"));
                        response.setProperty(rt, "message", jsi::String::createFromUtf8(rt, "Database already initialized"));
                        response.setProperty(rt, "databaseName", jsi::String::createFromUtf8(rt, dbName));
                        response.setProperty(rt, "version", jsi::Value(expectedVersion));
                        return response;
                    }

                    int errCode = 0;

                    // 创建配置对象
                    OH_Rdb_ConfigV2 *config = OH_Rdb_CreateConfig();
                    if (config == NULL)
                    {
                        throw jsi::JSError(rt, "Failed to create database config");
                    }

                    // 设置数据库文件目录
                    OH_Rdb_SetDatabaseDir(config, "/data/storage/el2/database");

                    // 使用传入的数据库名称
                    std::string storeName = dbName + ".db";
                    OH_Rdb_SetStoreName(config, storeName.c_str());

                    // 设置应用包名和模块名（需要根据实际应用修改）
                    OH_Rdb_SetBundleName(config, "com.harmony.watermelondb.demo");
                    OH_Rdb_SetModuleName(config, "entry");

                    // 设置安全级别和加密
                    OH_Rdb_SetSecurityLevel(config, OH_Rdb_SecurityLevel::S1);
                    OH_Rdb_SetEncrypted(config, false);

                    // 设置区域（area）和数据库类型（dbType）
                    OH_Rdb_SetArea(config, RDB_SECURITY_AREA_EL2);
                    OH_Rdb_SetDbType(config, 1);
                    OH_Rdb_SetPersistent(config, 1);
                    OH_Rdb_SetReadOnly(config, 0);

                    // 获取数据库操作实例
                    globalStore = OH_Rdb_CreateOrOpen(config, &errCode);
                    OH_Rdb_DestroyConfig(config); // 配置对象可以销毁了

                    if (globalStore == NULL || errCode != RDB_OK)
                    {
                        DLOG(ERROR) << "123456789 数据库初始化失败 - 错误代码: " << errCode;
                        throw jsi::JSError(rt, "Database initialization failed with error code: " + std::to_string(errCode));
                    }

                    isDatabaseInitialized = true;
                    DLOG(ERROR) << "123456789 数据库初始化成功 - store: " << globalStore;
                    //-------------创建测试表并插入数据-----------------------------
                    // const char *createTableSQL = "CREATE TABLE IF NOT EXISTS movies (id TEXT PRIMARY KEY, title TEXT, year INTEGER, genre TEXT)";
                    // errCode = OH_Rdb_ExecuteV2(globalStore, createTableSQL, nullptr, nullptr);
                    // if (errCode != RDB_OK)
                    // {
                    //     DLOG(ERROR) << "123456789 创建表失败: " << errCode;
                    // }
                    // else
                    // {
                    //     DLOG(ERROR) << "123456789 表创建成功";

                    //     // 插入测试数据
                    //     const char *insertSQL = "INSERT OR REPLACE INTO movies (id, title, year, genre) VALUES ('6', '测试6', 33333, 'cccccc')";

                    //     errCode = OH_Rdb_ExecuteV2(globalStore, insertSQL, nullptr, nullptr);
                    //     DLOG(ERROR) << "123456789 插入数据的结果: " << errCode;
                    // }
                    //----------------------删除数据--------------------------
                    // const char *dropTableSQL = "DROP TABLE IF EXISTS movies";
                    // errCode = OH_Rdb_ExecuteV2(globalStore, dropTableSQL, nullptr, nullptr);
                    // DLOG(ERROR) << "123456789 删除表结果: " << errCode;
                    //------------------------------------------------
                    // 创建响应对象
                    jsi::Object response(rt);
                    response.setProperty(rt, "code", jsi::String::createFromUtf8(rt, "ok"));
                    response.setProperty(rt, "message", jsi::String::createFromUtf8(rt, "Database initialized successfully"));
                    response.setProperty(rt, "databaseName", jsi::String::createFromUtf8(rt, dbName));
                    response.setProperty(rt, "version", jsi::Value(expectedVersion));

                    DLOG(ERROR) << "123456789 初始化完成";
                    return response;
                });

            // 2. setUpWithSchema方法
            auto setUpWithSchemaFunc = jsi::Function::createFromHostFunction(
                rt,
                jsi::PropNameID::forAscii(rt, "setUpWithSchema"),
                3,
                [](jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args, size_t count) -> jsi::Value
                {
                    if (count < 3)
                    {
                        throw jsi::JSError(rt, "setUpWithSchema requires 3 arguments");
                    }

                    std::string dbName = args[0].getString(rt).utf8(rt);
                    int schemaVersion = (int)args[2].getNumber();

                    DLOG(ERROR) << "123456789 设置Schema调用 - 数据库名: " << dbName
                                << ", schema版本: " << schemaVersion;

                    try
                    {
                        std::lock_guard<std::mutex> lock(storeMutex);

                        // 检查数据库是否已初始化
                        if (!isDatabaseInitialized || globalStore == nullptr)
                        {
                            throw jsi::JSError(rt, "Database not initialized. Call initialize() first.");
                        }

                        DLOG(ERROR) << "123456789 Schema设置 - 数据库: " << dbName;

                        // 解析schema JSON对象
                        jsi::Object schemaObj = args[1].getObject(rt);

                        // 获取tables数组
                        jsi::Array tablesArray = jsi::Array::createWithElements(rt);
                        if (schemaObj.hasProperty(rt, "tables"))
                        {
                            tablesArray = schemaObj.getProperty(rt, "tables").getObject(rt).getArray(rt);
                        }
                        else
                        {
                            // 如果没有tables属性，假设整个对象就是tables数组
                            tablesArray = args[1].getObject(rt).getArray(rt);
                        }

                        std::vector<std::string> tableNames;
                        std::vector<std::string> createTableSQLs;

                        DLOG(ERROR) << "123456789 发现 " << tablesArray.size(rt) << " 个表";

                        // 遍历所有表
                        for (size_t i = 0; i < tablesArray.size(rt); i++)
                        {
                            jsi::Object tableObj = tablesArray.getValueAtIndex(rt, i).getObject(rt);

                            // 获取表名
                            std::string tableName = tableObj.getProperty(rt, "name").getString(rt).utf8(rt);
                            tableNames.push_back(tableName);

                            DLOG(ERROR) << "123456789 处理表: " << tableName;

                            // 获取columns数组
                            jsi::Array columnsArray = tableObj.getProperty(rt, "columns").getObject(rt).getArray(rt);

                            // 构建CREATE TABLE语句
                            std::string createSQL = "CREATE TABLE IF NOT EXISTS " + tableName + " (";
                            std::vector<std::string> columnDefs;

                            // 遍历所有列
                            for (size_t j = 0; j < columnsArray.size(rt); j++)
                            {
                                jsi::Object columnObj = columnsArray.getValueAtIndex(rt, j).getObject(rt);

                                std::string colName = columnObj.getProperty(rt, "name").getString(rt).utf8(rt);
                                std::string colType = columnObj.getProperty(rt, "type").getString(rt).utf8(rt);

                                // 映射WatermelonDB类型到SQLite类型
                                std::string sqlType;
                                if (colType == "string" || colType == "text")
                                {
                                    sqlType = "TEXT";
                                }
                                else if (colType == "number" || colType == "int" || colType == "integer" || colType == "float" || colType == "double")
                                {
                                    sqlType = "INTEGER";
                                }
                                else if (colType == "boolean" || colType == "bool")
                                {
                                    sqlType = "INTEGER";
                                }
                                else
                                {
                                    sqlType = "TEXT"; // 默认类型
                                }

                                // 检查是否是主键
                                bool isPrimaryKey = false;
                                if (columnObj.hasProperty(rt, "isPrimary"))
                                {
                                    isPrimaryKey = columnObj.getProperty(rt, "isPrimary").getBool();
                                }
                                else if (colName == "id" && colType == "string")
                                {
                                    // 如果列名为id且类型为string，默认作为主键（WatermelonDB约定）
                                    isPrimaryKey = true;
                                }

                                std::string columnDef = colName + " " + sqlType;

                                // 如果是主键，添加PRIMARY KEY约束
                                if (isPrimaryKey)
                                {
                                    columnDef += " PRIMARY KEY";
                                }

                                columnDefs.push_back(columnDef);
                                DLOG(ERROR) << "123456789 表 " << tableName << " 列: " << colName
                                            << " 类型: " << colType
                                            << (isPrimaryKey ? " (主键)" : "");
                            }

                            // 添加标准WatermelonDB列
                            columnDefs.push_back("_status TEXT");
                            columnDefs.push_back("_changed TEXT");

                            // 完成SQL语句
                            for (size_t k = 0; k < columnDefs.size(); k++)
                            {
                                createSQL += columnDefs[k];
                                if (k < columnDefs.size() - 1)
                                {
                                    createSQL += ", ";
                                }
                            }
                            createSQL += ")";

                            createTableSQLs.push_back(createSQL);
                            DLOG(ERROR) << "123456789 创建表SQL: " << createSQL;

                            // 如果有索引定义，也处理
                            if (tableObj.hasProperty(rt, "indexes"))
                            {
                                jsi::Array indexesArray = tableObj.getProperty(rt, "indexes").getObject(rt).getArray(rt);
                                for (size_t j = 0; j < indexesArray.size(rt); j++)
                                {
                                    jsi::Object indexObj = indexesArray.getValueAtIndex(rt, j).getObject(rt);
                                    std::string indexName = indexObj.getProperty(rt, "name").getString(rt).utf8(rt);
                                    jsi::Array indexColumns = indexObj.getProperty(rt, "columns").getObject(rt).getArray(rt);

                                    std::string indexSQL = "CREATE INDEX IF NOT EXISTS " + indexName +
                                                           " ON " + tableName + " (";

                                    for (size_t k = 0; k < indexColumns.size(rt); k++)
                                    {
                                        std::string colName = indexColumns.getValueAtIndex(rt, k).getString(rt).utf8(rt);
                                        indexSQL += colName;
                                        if (k < indexColumns.size(rt) - 1)
                                        {
                                            indexSQL += ", ";
                                        }
                                    }
                                    indexSQL += ")";

                                    createTableSQLs.push_back(indexSQL);
                                    DLOG(ERROR) << "123456789 创建索引SQL: " << indexSQL;
                                }
                            }
                        }

                        // 执行所有SQL语句
                        int errCode = 0;
                        for (const auto &sql : createTableSQLs)
                        {
                            DLOG(ERROR) << "123456789 正在执行SQL: " << sql;
                            int result = OH_Rdb_ExecuteV2(globalStore, sql.c_str(), nullptr, nullptr);
                            if (result != RDB_OK)
                            {
                                DLOG(ERROR) << "123456789 执行SQL失败: " << sql << ", 错误代码: " << result;
                                throw jsi::JSError(rt, "Failed to create table, SQL: " + sql + ", error code: " + std::to_string(result));
                            }
                        }

                        DLOG(ERROR) << "123456789 Schema设置完成，创建了 " << tableNames.size() << " 个表，执行了 " << createTableSQLs.size() << " 条SQL语句";

                        jsi::Object response(rt);
                        response.setProperty(rt, "code", jsi::String::createFromUtf8(rt, "ok"));
                        response.setProperty(rt, "message", jsi::String::createFromUtf8(rt, "Schema setup completed"));
                        response.setProperty(rt, "version", jsi::Value(schemaVersion));
                        response.setProperty(rt, "tablesCreated", jsi::Value((int)tableNames.size()));
                        response.setProperty(rt, "queriesExecuted", jsi::Value((int)createTableSQLs.size()));

                        return response;
                    }
                    catch (const std::exception &e)
                    {
                        DLOG(ERROR) << "123456789 setUpWithSchema失败: " << e.what();
                        throw jsi::JSError(rt, "setUpWithSchema failed: " + std::string(e.what()));
                    }
                    catch (const jsi::JSError &e)
                    {
                        DLOG(ERROR) << "123456789 JS错误: " << e.getMessage();
                        throw;
                    }
                });

            // 3. setUpWithMigrations方法
            auto setUpWithMigrationsFunc = jsi::Function::createFromHostFunction(
                rt,
                jsi::PropNameID::forAscii(rt, "setUpWithMigrations"),
                4,
                [](jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args, size_t count) -> jsi::Value
                {
                    if (count < 4)
                    {
                        throw jsi::JSError(rt, "setUpWithMigrations requires 4 arguments");
                    }

                    std::string dbName = args[0].getString(rt).utf8(rt);
                    std::string migrationSchema = args[1].getString(rt).utf8(rt);
                    int fromVersion = (int)args[2].getNumber();
                    int toVersion = (int)args[3].getNumber();

                    DLOG(ERROR) << "123456789 迁移设置调用 - 数据库名: " << dbName
                                << ", 从版本: " << fromVersion << ", 到版本: " << toVersion;

                    try
                    {
                        std::lock_guard<std::mutex> lock(storeMutex);

                        // 检查数据库是否已初始化
                        if (!isDatabaseInitialized || globalStore == nullptr)
                        {
                            throw jsi::JSError(rt, "Database not initialized. Call initialize() first.");
                        }

                        // 开始事务
                        int beginResult = OH_Rdb_BeginTransaction(globalStore);
                        if (beginResult != RDB_OK)
                        {
                            throw jsi::JSError(rt, "Failed to begin transaction for migrations");
                        }

                        bool success = true;
                        std::string errorMessage;

                        try
                        {
                            // 解析迁移schema（JSON格式）
                            // 期望格式: {"migrations": [{"to_version": 2, "sql": "CREATE TABLE..."}, ...]}
                            DLOG(ERROR) << "123456789 迁移schema: " << migrationSchema;

                            // 简单的JSON解析实现
                            if (migrationSchema.empty() || migrationSchema[0] != '{' || migrationSchema[migrationSchema.length() - 1] != '}')
                            {
                                throw std::runtime_error("Invalid migration schema format");
                            }

                            // 查找migrations数组
                            size_t migrationsPos = migrationSchema.find("\"migrations\":");
                            if (migrationsPos == std::string::npos)
                            {
                                throw std::runtime_error("Migration schema missing 'migrations' field");
                            }

                            // 提取migrations数组内容
                            size_t arrayStart = migrationSchema.find('[', migrationsPos);
                            size_t arrayEnd = migrationSchema.find(']', arrayStart);
                            if (arrayStart == std::string::npos || arrayEnd == std::string::npos)
                            {
                                throw std::runtime_error("Invalid migrations array format");
                            }

                            std::string migrationsArray = migrationSchema.substr(arrayStart, arrayEnd - arrayStart + 1);
                            DLOG(ERROR) << "123456789 迁移数组: " << migrationsArray;

                            // 执行从fromVersion到toVersion的迁移
                            for (int version = fromVersion + 1; version <= toVersion; version++)
                            {
                                DLOG(ERROR) << "123456789 执行迁移到版本: " << version;

                                // 在migrations数组中查找对应版本的迁移
                                std::string versionStr = "\"to_version\":" + std::to_string(version);
                                size_t versionPos = migrationsArray.find(versionStr);

                                if (versionPos != std::string::npos)
                                {
                                    // 查找SQL语句
                                    size_t sqlPos = migrationsArray.find("\"sql\":", versionPos);
                                    if (sqlPos != std::string::npos)
                                    {
                                        size_t sqlStart = migrationsArray.find('\"', sqlPos + 6) + 1;
                                        size_t sqlEnd = migrationsArray.find('\"', sqlStart);
                                        if (sqlStart != std::string::npos && sqlEnd != std::string::npos)
                                        {
                                            std::string migrationSql = migrationsArray.substr(sqlStart, sqlEnd - sqlStart);
                                            DLOG(ERROR) << "123456789 执行迁移SQL: " << migrationSql;

                                            // 执行迁移SQL
                                            int result = OH_Rdb_ExecuteV2(globalStore, migrationSql.c_str(), nullptr, nullptr);
                                            if (result != RDB_OK)
                                            {
                                                throw std::runtime_error("Migration to version " + std::to_string(version) + " failed, SQL: " + migrationSql + ", error code: " + std::to_string(result));
                                            }
                                        }
                                    }
                                }
                                else
                                {
                                    DLOG(ERROR) << "123456789 未找到版本 " << version << " 的迁移，跳过";
                                }
                            }

                            success = true;
                        }
                        catch (const std::exception &e)
                        {
                            success = false;
                            errorMessage = e.what();
                        }

                        // 根据执行结果提交或回滚事务
                        if (success)
                        {
                            int commitResult = OH_Rdb_Commit(globalStore);
                            if (commitResult != RDB_OK)
                            {
                                OH_Rdb_RollBack(globalStore);
                                throw jsi::JSError(rt, "Failed to commit transaction for migrations");
                            }

                            jsi::Object response(rt);
                            response.setProperty(rt, "code", jsi::String::createFromUtf8(rt, "ok"));
                            response.setProperty(rt, "message", jsi::String::createFromUtf8(rt, "Migrations completed successfully"));
                            response.setProperty(rt, "fromVersion", jsi::Value(fromVersion));
                            response.setProperty(rt, "toVersion", jsi::Value(toVersion));

                            DLOG(ERROR) << "123456789 迁移完成 - 从版本 " << fromVersion << " 到 " << toVersion;
                            return response;
                        }
                        else
                        {
                            int rollbackResult = OH_Rdb_RollBack(globalStore);
                            if (rollbackResult != RDB_OK)
                            {
                                DLOG(ERROR) << "123456789 回滚事务失败";
                            }
                            throw jsi::JSError(rt, "setUpWithMigrations failed: " + errorMessage);
                        }
                    }
                    catch (const std::exception &e)
                    {
                        // 确保在异常情况下回滚事务
                        OH_Rdb_RollBack(globalStore);
                        throw jsi::JSError(rt, "setUpWithMigrations failed: " + std::string(e.what()));
                    }
                });

            // 4. find方法
            auto findFunc = jsi::Function::createFromHostFunction(
                rt,
                jsi::PropNameID::forAscii(rt, "find"),
                2,
                [](jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args, size_t count) -> jsi::Value
                {
                    if (count < 2)
                    {
                        throw jsi::JSError(rt, "find requires 2 arguments");
                    }

                    // 提取参数
                    std::string tableName = args[0].getString(rt).utf8(rt);
                    std::string id = args[1].getString(rt).utf8(rt);

                    DLOG(ERROR) << "123456789 find调用 - 表: " << tableName << ", ID: " << id;

                    try
                    {
                        std::lock_guard<std::mutex> lock(storeMutex);

                        // 检查数据库是否已初始化
                        if (!isDatabaseInitialized || globalStore == nullptr)
                        {
                            throw jsi::JSError(rt, "Database not initialized. Call initialize() first.");
                        }

                        // 构建查询SQL
                        std::string sql = "SELECT * FROM " + tableName + " WHERE id = ?";
                        DLOG(ERROR) << "123456789 正在执行SQL查询: " << sql;

                        // 创建结果对象
                        auto result = jsi::Object(rt);
                        result.setProperty(rt, "id", jsi::String::createFromUtf8(rt, id));
                        result.setProperty(rt, "table", jsi::String::createFromUtf8(rt, tableName));

                        //---------------------测试查询----------------------------------------
                        // OH_Cursor *testCursor = OH_Rdb_ExecuteQueryV2(globalStore, "SELECT * FROM movies", nullptr);
                        // if (testCursor != nullptr)
                        // {
                        //     int rowCount = 0;
                        //     while (testCursor->goToNextRow(testCursor) == RDB_OK)
                        //     {
                        //         rowCount++;
                        //         int64_t idValue;
                        //         char titleValue[256] = {0};
                        //         int64_t yearValue;

                        //         if (testCursor->getInt64(testCursor, 0, &idValue) == RDB_OK)
                        //         {
                        //             testCursor->getText(testCursor, 1, titleValue, sizeof(titleValue));
                        //             testCursor->getInt64(testCursor, 2, &yearValue);
                        //             DLOG(ERROR) << "123456789 数据 - id:" << idValue << " title:" << titleValue << " year:" << yearValue;
                        //         }
                        //     }

                        //     if (rowCount == 0)
                        //     {
                        //         DLOG(ERROR) << "123456789 movies表为空";
                        //     }
                        //     else
                        //     {
                        //         DLOG(ERROR) << "123456789 共找到" << rowCount << "条数据";
                        //     }

                        //     testCursor->destroy(testCursor);
                        // }
                        //-------------------------------------------------------------

                        // 执行查询
                        OH_Cursor *cursor = OH_Rdb_ExecuteQueryV2(globalStore, sql.c_str(), nullptr);
                        if (cursor == nullptr)
                        {
                            result.setProperty(rt, "found", jsi::Value(false));
                            result.setProperty(rt, "error", jsi::String::createFromUtf8(rt, "Query failed"));
                        }
                        else
                        {
                            if (cursor->goToNextRow(cursor) == RDB_OK)
                            {
                                int count = 0;
                                cursor->getColumnCount(cursor, &count);
                                for (int i = 0; i < count; i++)
                                {
                                    // 获取列名
                                    char columnName[256] = {0};
                                    if (cursor->getColumnName(cursor, i, columnName, sizeof(columnName)) == RDB_OK)
                                    {
                                        DLOG(ERROR) << "123456789 第" << i << "列 列名: " << columnName;
                                        OH_ColumnType columnType;
                                        jsi::Value cellValue = jsi::Value::null();

                                        // 获取列类型
                                        if (cursor->getColumnType(cursor, i, &columnType) == RDB_OK)
                                        {
                                            switch (columnType)
                                            {
                                            case TYPE_INT64:
                                            {
                                                int64_t intValue;
                                                if (cursor->getInt64(cursor, i, &intValue) == RDB_OK)
                                                {
                                                    cellValue = jsi::Value(static_cast<double>(intValue));
                                                }
                                                break;
                                            }
                                            case TYPE_REAL:
                                            {
                                                double doubleValue;
                                                if (cursor->getReal(cursor, i, &doubleValue) == RDB_OK)
                                                {
                                                    cellValue = jsi::Value(doubleValue);
                                                }
                                                break;
                                            }
                                            case TYPE_TEXT:
                                            {
                                                char textValue[1024] = {0};
                                                if (cursor->getText(cursor, i, textValue, sizeof(textValue)) == RDB_OK)
                                                {
                                                    if (strlen(textValue) > 0)
                                                    {
                                                        cellValue = jsi::String::createFromUtf8(rt, textValue);
                                                    }
                                                }
                                                break;
                                            }
                                            case TYPE_BLOB:
                                            {
                                                // BLOB类型暂时返回null
                                                cellValue = jsi::Value::null();
                                                break;
                                            }
                                            case TYPE_NULL:
                                            {
                                                cellValue = jsi::Value::null();
                                                break;
                                            }
                                            default:
                                                DLOG(ERROR) << "123456789 find未知列类型: " << columnType;
                                                break;
                                            }
                                        }

                                        // 设置属性到结果对象
                                        result.setProperty(rt, columnName, cellValue);
                                    }
                                }

                                // 设置固定属性
                                result.setProperty(rt, "found", jsi::Value(true));
                                result.setProperty(rt, "_status", jsi::String::createFromUtf8(rt, "synced"));
                            }
                            else
                            {
                                result.setProperty(rt, "found", jsi::Value(false));
                            }

                            // 清理游标
                            cursor->destroy(cursor);
                        }

                        DLOG(ERROR) << "123456789 find返回结果";
                        return result;
                    }
                    catch (const jsi::JSError &e)
                    {
                        throw e;
                    }
                    catch (const std::exception &e)
                    {
                        auto errorResult = jsi::Object(rt);
                        errorResult.setProperty(rt, "id", jsi::String::createFromUtf8(rt, id));
                        errorResult.setProperty(rt, "table", jsi::String::createFromUtf8(rt, tableName));
                        errorResult.setProperty(rt, "found", jsi::Value(false));
                        errorResult.setProperty(rt, "error", jsi::String::createFromUtf8(rt, e.what()));

                        DLOG(ERROR) << "123456789 find错误: " << e.what();
                        return errorResult;
                    }
                });

            // 5. query方法
            auto queryFunc = jsi::Function::createFromHostFunction(
                rt,
                jsi::PropNameID::forAscii(rt, "query"),
                3,
                [](jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args, size_t count) -> jsi::Value
                {
                    if (count < 1)
                    {
                        throw jsi::JSError(rt, "query requires 1 argument");
                    }

                    // std::string tableName = args[0].getString(rt).utf8(rt);
                    std::string sql = args[0].getString(rt).utf8(rt);

                    // DLOG(ERROR) << "123456789 query调用 - 表: " << tableName << ", SQL: " << sql;

                    try
                    {
                        std::lock_guard<std::mutex> lock(storeMutex);

                        // 检查数据库是否已初始化
                        if (!isDatabaseInitialized || globalStore == nullptr)
                        {
                            throw jsi::JSError(rt, "Database not initialized. Call initialize() first.");
                        }

                        // 构建完整的SQL查询语句
                        // std::string fullSql = "SELECT * FROM " + tableName + " WHERE " + sql;
                        std::string fullSql = sql;
                        DLOG(ERROR) << "123456789 query调用 - 完整SQL: " << fullSql;
                        // 执行查询
                        OH_Cursor *cursor = OH_Rdb_ExecuteQueryV2(globalStore, fullSql.c_str(), nullptr);
                        DLOG(ERROR) << "123456789 query调用 - 结果: " << cursor;
                        if (cursor == nullptr)
                        {
                            throw jsi::JSError(rt, "Failed to execute query: " + fullSql);
                        }

                        // 处理查询结果
                        std::vector<jsi::Value> resultRows;
                        int rowIndex = 0;

                        // 遍历结果集
                        while (cursor->goToNextRow(cursor) == RDB_OK)
                        {
                            // 获取列数
                            int columnCount = 0;
                            if (cursor->getColumnCount(cursor, &columnCount) != RDB_OK)
                            {
                                columnCount = 0;
                            }

                            jsi::Object rowObject(rt);

                            // 遍历每一列
                            for (int i = 0; i < columnCount; i++)
                            {
                                // 获取列名
                                char columnName[256] = {0};
                                if (cursor->getColumnName(cursor, i, columnName, sizeof(columnName)) == RDB_OK)
                                {
                                    OH_ColumnType columnType;
                                    jsi::Value cellValue = jsi::Value::null();

                                    // 获取列类型
                                    if (cursor->getColumnType(cursor, i, &columnType) == RDB_OK)
                                    {
                                        switch (columnType)
                                        {
                                        case TYPE_INT64:
                                        {
                                            int64_t intValue;
                                            if (cursor->getInt64(cursor, i, &intValue) == RDB_OK)
                                            {
                                                cellValue = jsi::Value(static_cast<double>(intValue));
                                            }
                                            break;
                                        }
                                        case TYPE_REAL:
                                        {
                                            double doubleValue;
                                            if (cursor->getReal(cursor, i, &doubleValue) == RDB_OK)
                                            {
                                                cellValue = jsi::Value(doubleValue);
                                            }
                                            break;
                                        }
                                        case TYPE_TEXT:
                                        {
                                            char textValue[1024] = {0};
                                            if (cursor->getText(cursor, i, textValue, sizeof(textValue)) == RDB_OK)
                                            {
                                                if (strlen(textValue) > 0)
                                                {
                                                    cellValue = jsi::String::createFromUtf8(rt, textValue);
                                                }
                                            }
                                            break;
                                        }
                                        case TYPE_BLOB:
                                        {
                                            // BLOB类型暂时返回null
                                            cellValue = jsi::Value::null();
                                            break;
                                        }
                                        case TYPE_NULL:
                                        {
                                            cellValue = jsi::Value::null();
                                            break;
                                        }
                                        default:
                                            DLOG(ERROR) << "123456789 query未知列类型: " << columnType;
                                            break;
                                        }
                                    }

                                    rowObject.setProperty(rt, columnName, cellValue);
                                }
                            }

                            // resultArray.setValueAtIndex(rt, rowIndex, rowObject);
                            resultRows.push_back(std::move(rowObject));
                            rowIndex++;
                        }

                        // 创建最终结果数组
                        jsi::Array resultArray = jsi::Array(rt, resultRows.size());
                        for (size_t i = 0; i < resultRows.size(); i++)
                        {
                            resultArray.setValueAtIndex(rt, i, resultRows[i]);
                        }

                        // 清理游标
                        cursor->destroy(cursor);

                        DLOG(ERROR) << "123456789 query完成，返回行数: " << rowIndex;
                        return resultArray;
                    }
                    catch (const std::exception &e)
                    {
                        throw jsi::JSError(rt, "query failed: " + std::string(e.what()));
                    }
                });

            // 6. queryAsArray方法
            auto queryAsArrayFunc = jsi::Function::createFromHostFunction(
                rt,
                jsi::PropNameID::forAscii(rt, "queryAsArray"),
                2,
                [](jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args, size_t count) -> jsi::Value
                {
                    if (count < 2)
                    {
                        throw jsi::JSError(rt, "queryAsArray requires 2 arguments");
                    }

                    std::string tableName = args[0].getString(rt).utf8(rt);
                    std::string sql = args[1].getString(rt).utf8(rt);

                    DLOG(ERROR) << "123456789 queryAsArray调用 - 表: " << tableName;

                    try
                    {
                        std::lock_guard<std::mutex> lock(storeMutex);

                        // 检查数据库是否已初始化
                        if (!isDatabaseInitialized || globalStore == nullptr)
                        {
                            throw jsi::JSError(rt, "Database not initialized. Call initialize() first.");
                        }

                        // 执行查询并获取游标
                        OH_Cursor *cursor = OH_Rdb_ExecuteQueryV2(globalStore, sql.c_str(), nullptr);
                        if (cursor == nullptr)
                        {
                            throw jsi::JSError(rt, "Failed to execute query");
                        }

                        std::vector<jsi::Value> resultRows;
                        int rowIndex = 0;

                        // 遍历结果集
                        while (cursor->goToNextRow(cursor) == RDB_OK)
                        {
                            int columnCount = 0;
                            if (cursor->getColumnCount(cursor, &columnCount) == RDB_OK)
                            {
                                jsi::Array rowArray = jsi::Array(rt, columnCount);

                                for (int i = 0; i < columnCount; i++)
                                {
                                    OH_ColumnType columnType;
                                    jsi::Value cellValue = jsi::Value::null();

                                    // 获取列类型
                                    if (cursor->getColumnType(cursor, i, &columnType) == RDB_OK)
                                    {
                                        switch (columnType)
                                        {
                                        case TYPE_INT64:
                                        {
                                            int64_t intValue;
                                            if (cursor->getInt64(cursor, i, &intValue) == RDB_OK)
                                            {
                                                cellValue = jsi::Value(static_cast<double>(intValue));
                                            }
                                            break;
                                        }
                                        case TYPE_REAL:
                                        {
                                            double doubleValue;
                                            if (cursor->getReal(cursor, i, &doubleValue) == RDB_OK)
                                            {
                                                cellValue = jsi::Value(doubleValue);
                                            }
                                            break;
                                        }
                                        case TYPE_TEXT:
                                        {
                                            char textValue[1024] = {0};
                                            if (cursor->getText(cursor, i, textValue, sizeof(textValue)) == RDB_OK)
                                            {
                                                if (strlen(textValue) > 0)
                                                {
                                                    cellValue = jsi::String::createFromUtf8(rt, textValue);
                                                }
                                            }
                                            break;
                                        }
                                        case TYPE_BLOB:
                                        {
                                            // BLOB类型暂时返回null
                                            cellValue = jsi::Value::null();
                                            break;
                                        }
                                        case TYPE_NULL:
                                        {
                                            cellValue = jsi::Value::null();
                                            break;
                                        }
                                        default:
                                            DLOG(ERROR) << "123456789 queryAsArray未知列类型: " << columnType;
                                            break;
                                        }
                                    }

                                    rowArray.setValueAtIndex(rt, i, cellValue);
                                }

                                resultRows.push_back(std::move(rowArray));
                                rowIndex++;
                            }
                            else
                            {
                                DLOG(ERROR) << "123456789 queryAsArray无法获取列数";
                            }
                        }

                        // 清理游标
                        cursor->destroy(cursor);

                        // 创建结果数组
                        jsi::Array resultArray = jsi::Array(rt, resultRows.size());
                        for (size_t i = 0; i < resultRows.size(); i++)
                        {
                            resultArray.setValueAtIndex(rt, i, resultRows[i]);
                        }

                        DLOG(ERROR) << "123456789 queryAsArray完成，返回行数: " << rowIndex;
                        return resultArray;
                    }
                    catch (const std::exception &e)
                    {
                        throw jsi::JSError(rt, "queryAsArray failed: " + std::string(e.what()));
                    }
                });

            // 7. queryIds方法
            auto queryIdsFunc = jsi::Function::createFromHostFunction(
                rt,
                jsi::PropNameID::forAscii(rt, "queryIds"),
                2,
                [](jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args, size_t count) -> jsi::Value
                {
                    if (count < 2)
                    {
                        throw jsi::JSError(rt, "queryIds requires 2 arguments");
                    }

                    std::string sql = args[0].getString(rt).utf8(rt);

                    jsi::Array arguments = jsi::Array(rt, 0);
                    if (!args[1].isNull() && !args[1].isUndefined())
                    {
                        if (args[1].isObject() && args[1].getObject(rt).isArray(rt))
                        {
                            arguments = args[1].getObject(rt).getArray(rt);
                            DLOG(ERROR) << "123456789 queryIds获取到参数数组，长度: " << arguments.size(rt);
                        }
                        else
                        {
                            DLOG(ERROR) << "123456789 queryIds第二个参数不是数组";
                        }
                    }
                    DLOG(ERROR) << "123456789 queryIds调用 - SQL: " << sql;

                    try
                    {
                        std::lock_guard<std::mutex> lock(storeMutex);

                        // 检查数据库是否已初始化
                        if (!isDatabaseInitialized || globalStore == nullptr)
                        {
                            throw jsi::JSError(rt, "Database not initialized. Call initialize() first.");
                        }
                        std::vector<jsi::Value> ids;
                        // 执行SQL
                        OH_Cursor *cursor = OH_Rdb_ExecuteQueryV2(globalStore, sql.c_str(), nullptr);
                        while (cursor->goToNextRow(cursor) == RDB_OK)
                        {
                            OH_Data_Value *cellValue = nullptr;
                            OH_ColumnType columnType;
                            if (cursor->getColumnType(cursor, 0, &columnType) == RDB_OK)
                            {
                                jsi::Value jsValue;
                                switch (columnType)
                                {
                                case TYPE_INT64:
                                {
                                    int64_t intValue;
                                    if (cursor->getInt64(cursor, 0, &intValue) == RDB_OK)
                                    {
                                        jsValue = jsi::Value(static_cast<double>(intValue));
                                        ids.push_back(std::move(jsValue));
                                    }
                                    break;
                                }
                                case TYPE_REAL:
                                {
                                    double doubleValue;
                                    if (cursor->getReal(cursor, 0, &doubleValue) == RDB_OK)
                                    {
                                        jsValue = jsi::Value(doubleValue);
                                        ids.push_back(std::move(jsValue));
                                    }
                                    break;
                                }
                                case TYPE_TEXT:
                                {
                                    char textValue[1024] = {0};
                                    size_t textLength = sizeof(textValue);
                                    if (cursor->getText(cursor, 0, textValue, textLength) == RDB_OK)
                                    {
                                        if (textValue != nullptr)
                                        {
                                            jsValue = jsi::String::createFromUtf8(rt, textValue);
                                            ids.push_back(std::move(jsValue));
                                        }
                                        else
                                        {
                                            jsValue = jsi::Value::null();
                                            ids.push_back(std::move(jsValue));
                                        }
                                    }
                                    break;
                                }
                                case TYPE_NULL:
                                {
                                    jsValue = jsi::Value::null();
                                    ids.push_back(std::move(jsValue));
                                    break;
                                }
                                default:
                                    DLOG(ERROR) << "123456789 queryIds未知类型";
                                    break;
                                }
                            }
                        }
                        cursor->destroy(cursor);

                        jsi::Array resultArray = jsi::Array(rt, ids.size());
                        for (size_t i = 0; i < ids.size(); i++)
                        {
                            resultArray.setValueAtIndex(rt, i, ids[i]);
                        }

                        DLOG(ERROR) << "123456789 queryIds完成";
                        return resultArray;
                    }
                    catch (const std::exception &e)
                    {
                        throw jsi::JSError(rt, "queryIds failed: " + std::string(e.what()));
                    }
                });

            // 8. unsafeQueryRaw方法
            auto unsafeQueryRawFunc = jsi::Function::createFromHostFunction(
                rt,
                jsi::PropNameID::forAscii(rt, "unsafeQueryRaw"),
                1,
                [](jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args, size_t count) -> jsi::Value
                {
                    if (count < 1)
                    {
                        throw jsi::JSError(rt, "unsafeQueryRaw requires 1 argument");
                    }

                    std::string sql = args[0].getString(rt).utf8(rt);

                    DLOG(ERROR) << "123456789 unsafeQueryRaw调用 - SQL: " << sql;

                    try
                    {
                        std::lock_guard<std::mutex> lock(storeMutex);

                        // 检查数据库是否已初始化
                        if (!isDatabaseInitialized || globalStore == nullptr)
                        {
                            throw jsi::JSError(rt, "Database not initialized. Call initialize() first.");
                        }

                        // 判断SQL类型（查询 vs 非查询）
                        bool isQuery = false;
                        std::string upperSql = sql;
                        std::transform(upperSql.begin(), upperSql.end(), upperSql.begin(), ::toupper);
                        if (upperSql.find("SELECT") == 0)
                        {
                            isQuery = true;
                        }

                        if (isQuery)
                        {
                            // 执行查询操作 - 使用OH_Rdb_ExecuteQueryV2
                            OH_Cursor *cursor = OH_Rdb_ExecuteQueryV2(globalStore, sql.c_str(), nullptr);
                            if (cursor == nullptr)
                            {
                                throw jsi::JSError(rt, "Failed to execute query: " + sql);
                            }

                            // 处理查询结果
                            int rowIndex = 0;
                            std::vector<jsi::Object> results;
                            while (cursor->goToNextRow(cursor) == RDB_OK)
                            {
                                int columnCount = 0;
                                if (cursor->getColumnCount(cursor, &columnCount) != RDB_OK)
                                {
                                    columnCount = 0;
                                }

                                jsi::Object rowObject(rt);

                                for (int i = 0; i < columnCount; i++)
                                {
                                    char columnName[256];
                                    if (cursor->getColumnName(cursor, i, columnName, sizeof(columnName)) == RDB_OK)
                                    {
                                        OH_ColumnType columnType;
                                        jsi::Value cellValue = jsi::Value::null();

                                        if (cursor->getColumnType(cursor, i, &columnType) == RDB_OK)
                                        {
                                        
                                            switch (columnType)
                                            {
                                            case 1: // TYPE_INT64
                                            {
                                                int64_t intValue;
                                                if (cursor->getInt64(cursor, i, &intValue) == RDB_OK)
                                                {
                                                    cellValue = jsi::Value(static_cast<double>(intValue));
                                                }
                                                break;
                                            }
                                            case 3: // TYPE_TEXT
                                            {
                                                char textValue[1024] = {0};
                                                if (cursor->getText(cursor, i, textValue, sizeof(textValue)) == RDB_OK)
                                                {
                                                    cellValue = jsi::String::createFromUtf8(rt, textValue);
                                                }
                                                break;
                                            }
                                            case 2: // TYPE_FLOAT
                                            {
                                                double doubleValue;
                                                if (cursor->getReal(cursor, i, &doubleValue) == RDB_OK)
                                                {
                                                    cellValue = jsi::Value(doubleValue);
                                                }
                                                break;
                                            }
                                            case 0: // TYPE_NULL
                                            {
                                                cellValue = jsi::Value::null();
                                                break;
                                            }
                                            case 4: // TYPE_BLOB
                                            {
                                                // BLOB类型暂不处理
                                                cellValue = jsi::Value::null();
                                                break;
                                            }
                                            }
                                        }

                                        rowObject.setProperty(rt, columnName, cellValue);
                                    }
                                }

                                results.push_back(std::move(rowObject));
                                rowIndex++;
                            }

                            jsi::Array resultArray = jsi::Array(rt, results.size());
                            for (size_t i = 0; i < results.size(); i++)
                            {
                                resultArray.setValueAtIndex(rt, i, results[i]);
                            }

                            if (cursor != nullptr)
                            {
                                cursor->destroy(cursor);
                            }

                            DLOG(ERROR) << "123456789 unsafeQueryRaw查询完成 - 返回 " << rowIndex << " 行数据";
                            return resultArray;
                        }
                        else
                        {
                            // 执行非查询操作（INSERT/UPDATE/DELETE等）
                            int result = OH_Rdb_ExecuteV2(globalStore, sql.c_str(), nullptr, nullptr);

                            if (result != RDB_OK)
                            {
                                throw jsi::JSError(rt, "Execute failed: " + sql + ", error: " + std::to_string(result));
                            }

                            DLOG(ERROR) << "123456789 unsafeQueryRaw非查询操作完成";
                            return jsi::Value::undefined();
                        }
                    }
                    catch (const std::exception &e)
                    {
                        throw jsi::JSError(rt, "unsafeQueryRaw failed: " + std::string(e.what()));
                    }
                });

            // 9. count方法
            auto countFunc = jsi::Function::createFromHostFunction(
                rt,
                jsi::PropNameID::forAscii(rt, "count"),
                2,
                [](jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args, size_t count) -> jsi::Value
                {
                    if (count < 1)
                    {
                        throw jsi::JSError(rt, "count requires 1 argument");
                    }

                    std::string sql = args[0].getString(rt).utf8(rt);

                    DLOG(ERROR) << "123456789 count调用 - SQL: " << sql;

                    try
                    {
                        std::lock_guard<std::mutex> lock(storeMutex);

                        // 检查数据库是否已初始化
                        if (!isDatabaseInitialized || globalStore == nullptr)
                        {
                            throw jsi::JSError(rt, "Database not initialized. Call initialize() first.");
                        }

                        // 执行COUNT查询
                        OH_Cursor *cursor = OH_Rdb_ExecuteQueryV2(globalStore, sql.c_str(), nullptr);
                        if (cursor == nullptr)
                        {
                            throw jsi::JSError(rt, "Failed to execute count query: " + sql);
                        }

                        int64_t countResult = 0;

                        // 移动到第一行
                        if (cursor->goToNextRow(cursor) == RDB_OK)
                        {
                            // 获取第一列的值（COUNT(*)的结果）
                            if (cursor->getInt64(cursor, 0, &countResult) != RDB_OK)
                            {
                                // 如果获取失败，记录错误并返回0
                                DLOG(ERROR) << "123456789 获取COUNT结果失败，返回0";
                                countResult = 0;
                            }
                        }

                        // 清理游标资源
                        if (cursor != nullptr)
                        {
                            cursor->destroy(cursor);
                        }

                        DLOG(ERROR) << "123456789 count完成 - 结果: " << countResult;

                        return jsi::Value(static_cast<double>(countResult));
                    }
                    catch (const std::exception &e)
                    {
                        throw jsi::JSError(rt, "count failed: " + std::string(e.what()));
                    }
                });

            // 10. batch方法
            auto batchFunc = jsi::Function::createFromHostFunction(
                rt,
                jsi::PropNameID::forAscii(rt, "batch"),
                1,
                [](jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args, size_t count) -> jsi::Value
                {
                    if (count < 1)
                    {
                        throw jsi::JSError(rt, "batch requires 1 argument");
                    }

                    jsi::Array operations = args[0].getObject(rt).getArray(rt);

                    DLOG(ERROR) << "123456789 batch调用 - 操作数量: " << operations.size(rt);
                    jsi::Array results(rt, operations.size(rt));
                    size_t index = 0;

                    try
                    {
                        std::lock_guard<std::mutex> lock(storeMutex);

                        // 检查数据库是否已初始化
                        if (!isDatabaseInitialized || globalStore == nullptr)
                        {
                            throw jsi::JSError(rt, "Database not initialized. Call initialize() first.");
                        }

                        // 开始事务
                        int beginResult = OH_Rdb_BeginTransaction(globalStore);
                        if (beginResult != RDB_OK)
                        {
                            throw jsi::JSError(rt, "Failed to begin transaction, error code: " + std::to_string(beginResult));
                        }

                        // 执行批量操作
                        for (size_t i = 0; i < operations.size(rt); i++)
                        {
                            DLOG(ERROR) << "123456789 batch调用 - 1111: " << i;
                            jsi::Value operationValue = operations.getValueAtIndex(rt, i);
                            if (operationValue.isObject())
                            {
                                jsi::Object operation = operationValue.getObject(rt);
                                std::string type = operation.getProperty(rt, "type").getString(rt).utf8(rt);
                                DLOG(ERROR) << "123456789 batch调用 - 当前操作索引: " << type;
                                std::string sql = operation.getProperty(rt, "sql").getString(rt).utf8(rt);
                                DLOG(ERROR) << "123456789 batch调用 - 当前操作SQL: " << sql;
                                jsi::Array jsArguments = operation.getProperty(rt, "arguments").getObject(rt).getArray(rt);
                                for (size_t j = 0; j < jsArguments.size(rt); j++)
                                {
                                    jsi::Value jsArgument = jsArguments.getValueAtIndex(rt, j);
                                    if (jsArgument.isString())
                                    {
                                        std::string arg = jsArgument.getString(rt).utf8(rt);
                                        sql.replace(sql.find("?"), 1, "'" + arg + "'");
                                    }
                                    else if (jsArgument.isNumber())
                                    {
                                        double arg = jsArgument.getNumber();
                                        sql.replace(sql.find("?"), 1, std::to_string(arg));
                                    }

                                    else if (jsArgument.isNull())
                                    {
                                        sql.replace(sql.find("?"), 1, "NULL");
                                    }
                                    else
                                    {
                                        throw jsi::JSError(rt, "Unsupported argument type in batch operation.");
                                    }
                                }

                                DLOG(ERROR) << "123456789 batch调用 - 最终操作SQL: " << sql;

                                if (type == "INSERT")
                                {
                                    // std::string checksql = "SELECT EXISTS(SELECT 1 FROM movies WHERE id = ?)";
                                    // if (jsArguments.size(rt) > 0)
                                    // {
                                    //     jsi::Value firstArg = jsArguments.getValueAtIndex(rt, 0);
                                    //     if (firstArg.isString())
                                    //     {
                                    //         std::string arg = firstArg.getString(rt).utf8(rt);
                                    //         checksql.replace(checksql.find("?"), 1, "'" + arg + "'");
                                    //     }
                                    //     else if (firstArg.isNumber())
                                    //     {
                                    //         int64_t arg = firstArg.getNumber();
                                    //         checksql.replace(checksql.find("?"), 1, std::to_string(arg));
                                    //     }
                                    // }
                                    // DLOG(ERROR) << "123456789 INSERTchecksql是: " << checksql;
                                    // OH_Cursor *checkcursor = OH_Rdb_ExecuteQueryV2(globalStore, checksql.c_str(), nullptr);
                                    // if (checkcursor != nullptr && checkcursor->goToNextRow(checkcursor) == RDB_OK)
                                    // {
                                    //     DLOG(ERROR) << "123456789 INSERT失败 - ID已存在，sql: " << checksql;
                                    //     throw jsi::JSError(rt, "This ID already exists. Please use a different ID.");
                                    // }

                                    DLOG(ERROR) << "123456789 批量执行: " << sql;
                                    int execResult = OH_Rdb_ExecuteV2(globalStore, sql.c_str(), nullptr, nullptr);
                                    DLOG(ERROR) << "123456789 执行INSERT操作, 结果: " << execResult;
                                    if (execResult != RDB_OK)
                                    {

                                        int rollbackResult = OH_Rdb_ExecuteV2(globalStore, "ROLLBACK", nullptr, nullptr);
                                        if (rollbackResult != RDB_OK)
                                        {
                                            DLOG(ERROR) << "123456789 回滚事务失败";
                                        }

                                        throw jsi::JSError(rt, "Execute failed for SQL: " + sql);
                                    }
                                    else
                                    {
                                        DLOG(ERROR) << "123456789 插入成功 sql: " << sql;
                                    }
                                }
                                else
                                {
                                    DLOG(ERROR) << "123456789 批量执行: " << sql;
                                    int execResult = OH_Rdb_ExecuteV2(globalStore, sql.c_str(), nullptr, nullptr);
                                    if (execResult != RDB_OK)
                                    {
                                        int rollbackResult = OH_Rdb_ExecuteV2(globalStore, "ROLLBACK", nullptr, nullptr);
                                        if (rollbackResult != RDB_OK)
                                        {
                                            DLOG(ERROR) << "123456789 回滚事务失败";
                                        }
                                        throw jsi::JSError(rt, "Execute failed for SQL: " + sql);
                                    }
                                }
                            }
                        }
                        DLOG(ERROR) << "123456789 batch调用 - 执行完成";
                        // 提交事务
                        OH_Rdb_Commit(globalStore);

                        return results;
                    }
                    catch (const std::exception &e)
                    {
                        throw jsi::JSError(rt, "batch failed: " + std::string(e.what()));
                    }
                });

            // 11. batchJSON方法
            auto batchJSONFunc = jsi::Function::createFromHostFunction(
                rt,
                jsi::PropNameID::forAscii(rt, "batchJSON"),
                1,
                [](jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args, size_t count) -> jsi::Value
                {
                    if (count < 1)
                    {
                        throw jsi::JSError(rt, "batchJSON requires 1 argument");
                    }

                    std::string operationsJson = args[0].getString(rt).utf8(rt);

                    DLOG(ERROR) << "123456789 batchJSON调用 - JSON长度: " << operationsJson.length();

                    try
                    {
                        std::lock_guard<std::mutex> lock(storeMutex);

                        // 检查数据库是否已初始化
                        if (!isDatabaseInitialized || globalStore == nullptr)
                        {
                            throw jsi::JSError(rt, "Database not initialized. Call initialize() first.");
                        }

                        // 开始事务
                        int beginResult = OH_Rdb_BeginTransaction(globalStore);
                        if (beginResult != RDB_OK)
                        {
                            throw jsi::JSError(rt, "Failed to begin transaction, error code: " + std::to_string(beginResult));
                        }

                        bool success = true;
                        std::string errorMessage;
                        // jsi::Array results(rt, 0);
                        size_t index = 0;

                        // 简单的JSON解析实现
                        if (operationsJson.empty() || operationsJson[0] != '[' || operationsJson[operationsJson.length() - 1] != ']')
                        {
                            throw std::runtime_error("Invalid JSON format - expected array");
                        }
                        auto jsonArray = nlohmann::json::parse(operationsJson);
                        jsi::Array results(rt, jsonArray.size());

                        for (const auto &operationObj : jsonArray)
                        {
                            // 解析的操作对象
                            if (!operationObj.is_object())
                            {
                                throw std::runtime_error("Invalid JSON format - expected object");
                            }

                            // 提取type和sql字段
                            if (!operationObj.contains("type") || !operationObj.contains("sql"))
                            {
                                throw std::runtime_error("Invalid JSON format - missing 'type' or 'sql' field");
                            }
                            std::string type = operationObj["type"];
                            std::string sql = operationObj["sql"];
                            DLOG(ERROR) << "123456789 batchJSON调用 - 操作类型: " << type << ", SQL: " << sql;
                            // 提取参数数组 (arguments)
                            auto argumentsArray = operationObj["arguments"];
                            DLOG(ERROR) << "123456789 batchJSON调用 - 参数数量: " << argumentsArray.size();
                            std::vector<std::string> arguments; // 用于存储参数值
                            for (size_t i = 0; i < argumentsArray.size(); ++i)
                            {
                                // 根据参数的实际类型进行处理
                                if (argumentsArray[i].is_string())
                                {
                                    std::string arg = argumentsArray[i].get<std::string>();
                                    arguments.push_back(arg);
                                    sql.replace(sql.find("?"), 1, "'" + arguments.back() + "'");
                                }
                                // 整数类型处理
                                else if (argumentsArray[i].is_number_integer())
                                {
                                    int64_t arg = argumentsArray[i].get<int64_t>();
                                    arguments.push_back(std::to_string(arg));
                                    sql.replace(sql.find("?"), 1, arguments.back());
                                }
                                // 浮点数类型处理
                                else if (argumentsArray[i].is_number_float())
                                {
                                    double arg = argumentsArray[i].get<double>();
                                    arguments.push_back(std::to_string(arg));
                                    sql.replace(sql.find("?"), 1, arguments.back());
                                }
                                // 布尔类型处理
                                else if (argumentsArray[i].is_boolean())
                                {
                                    bool arg = argumentsArray[i].get<bool>();
                                    arguments.push_back(arg ? "1" : "0");
                                    sql.replace(sql.find("?"), 1, arguments.back());
                                }
                                // NULL值处理
                                else if (argumentsArray[i].is_null())
                                {
                                    arguments.push_back("NULL");
                                    sql.replace(sql.find("?"), 1, arguments.back());
                                }
                                else
                                {
                                    throw std::runtime_error("Invalid JSON format - unsupported argument type");
                                }
                                DLOG(ERROR) << "123456789 batchJSON调用 - 参数 " << i << ": " << arguments.back();
                            }
                            DLOG(ERROR) << "123456789 batchJSON最终调用 - sql命令 : " << sql;

                            if (type == "INSERT" && !sql.empty())
                            {
                                // std::string checksql = "SELECT EXISTS(SELECT 1 FROM movies WHERE id = ?)";
                                // if (argumentsArray.size() > 0)
                                // {
                                //     if (argumentsArray[0].is_string())
                                //     {
                                //         std::string arg = argumentsArray[0].get<std::string>();
                                //         arguments.push_back(arg);
                                //         checksql.replace(checksql.find("?"), 1, "'" + arguments.back() + "'");
                                //     }
                                //     else if (argumentsArray[0].is_number_integer())
                                //     {
                                //         int64_t arg = argumentsArray[0].get<int64_t>();
                                //         arguments.push_back(std::to_string(arg));
                                //         checksql.replace(checksql.find("?"), 1, arguments.back());
                                //     }
                                //     else if (argumentsArray[0].is_number_float())
                                //     {
                                //         double arg = argumentsArray[0].get<double>();
                                //         arguments.push_back(std::to_string(arg));
                                //         checksql.replace(checksql.find("?"), 1, arguments.back());
                                //     }
                                // }
                                // DLOG(ERROR) << "123456789 INSERTchecksql是: " << checksql;
                                // OH_Cursor *checkcursor = OH_Rdb_ExecuteQueryV2(globalStore, checksql.c_str(), nullptr);
                                // if (checkcursor != nullptr && checkcursor->goToNextRow(checkcursor) == RDB_OK)
                                // {
                                //     DLOG(ERROR) << "123456789 INSERT失败 - ID已存在: " << arguments.back();
                                //     throw jsi::JSError(rt, "This ID already exists. Please use a different ID.");
                                // }

                                int execResult = OH_Rdb_ExecuteV2(globalStore, sql.c_str(), nullptr, nullptr);
                                if (execResult == RDB_OK)
                                {
                                    DLOG(ERROR) << "123456789 SQL插入执行成功: " << sql;
                                }
                                else
                                {
                                    success = false;
                                    DLOG(ERROR) << "123456789 SQL插入执行失败: " << sql;
                                }
                            }
                            else
                            {
                                int execResult = OH_Rdb_ExecuteV2(globalStore, sql.c_str(), nullptr, nullptr);
                                if (execResult != RDB_OK)
                                {
                                    success = false;
                                    DLOG(ERROR) << "123456789 SQL执行失败: " << sql;
                                }
                            }
                        }

                        // 根据执行结果提交或回滚事务
                        if (success)
                        {
                            int commitResult = OH_Rdb_Commit(globalStore);
                            DLOG(ERROR) << "123456789 :到这里的 " << commitResult;
                            if (commitResult != RDB_OK)
                            {
                                OH_Rdb_ExecuteV2(globalStore, "ROLLBACK", nullptr, nullptr);
                                throw jsi::JSError(rt, "Failed to commit transaction");
                            }
                            DLOG(ERROR) << "123456789 batchJSON完成 - 事务提交成功";
                        }
                        else
                        {
                            int rollbackResult = OH_Rdb_ExecuteV2(globalStore, "ROLLBACK", nullptr, nullptr);
                            if (rollbackResult != RDB_OK)
                            {
                                DLOG(ERROR) << "123456789 回滚事务失败";
                            }
                            throw jsi::JSError(rt, "batchJSON failed: " + errorMessage);
                        }

                        return results;
                    }
                    catch (const std::exception &e)
                    {
                        // 确保在异常情况下回滚事务
                        OH_Rdb_ExecuteV2(globalStore, "ROLLBACK", nullptr, nullptr);
                        throw jsi::JSError(rt, "batchJSON failed: " + std::string(e.what()));
                    }
                });

            // 12. getLocal方法
            auto getLocalFunc = jsi::Function::createFromHostFunction(
                rt,
                jsi::PropNameID::forAscii(rt, "getLocal"),
                1,
                [](jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args, size_t count) -> jsi::Value
                {
                    if (count < 1)
                    {
                        throw jsi::JSError(rt, "getLocal requires 1 argument");
                    }

                    std::string key = args[0].getString(rt).utf8(rt);

                    DLOG(ERROR) << "123456789 getLocal调用 - 键: " << key;

                    try
                    {
                        std::lock_guard<std::mutex> lock(storeMutex);

                        // 检查数据库是否已初始化
                        if (!isDatabaseInitialized || globalStore == nullptr)
                        {
                            throw jsi::JSError(rt, "Database not initialized. Call initialize() first.");
                        }

                        // 使用字符串拼接的方式构建SQL（避免复杂的参数化查询）
                        std::string sql = "SELECT value FROM local_storage WHERE key = '" + key + "'";

                        // 执行查询 - 使用nullptr作为第二个参数
                        OH_Cursor *cursor = OH_Rdb_ExecuteQueryV2(globalStore, sql.c_str(), nullptr);
                        if (cursor == nullptr)
                        {
                            DLOG(ERROR) << "123456789 查询失败 - 键: " << key;
                            return jsi::Value::null();
                        }

                        // 检查是否有结果
                        int rowCount = 0;
                        if (cursor->getRowCount(cursor, &rowCount) != RDB_OK)
                        {
                            rowCount = 0;
                        }
                        DLOG(ERROR) << "123456789查询行数: " << rowCount;

                        if (rowCount <= 0)
                        {
                            cursor->destroy(cursor);
                            DLOG(ERROR) << "123456789 未找到对应的值 - 键: " << key;
                            return jsi::Value::null();
                        }

                        // 移动到第一行
                        int moveResult = cursor->goToNextRow(cursor);
                        DLOG(ERROR) << "123456789 goToNextRow结果: " << moveResult;
                        if (moveResult != RDB_OK)
                        {
                            cursor->destroy(cursor);
                            DLOG(ERROR) << "123456789 移动游标失败 - 键: " << key;
                            return jsi::Value::null();
                        }

                        // 获取值
                        char value[1024];
                        int textLength = sizeof(value);
                        int getResult = cursor->getText(cursor, 0, value, textLength);
                        DLOG(ERROR) << "123456789 getText结果: " << getResult << ", 获取的值: " << (value ? value : "NULL");
                        if (getResult != RDB_OK || value == nullptr)
                        {
                            cursor->destroy(cursor);
                            DLOG(ERROR) << "123456789 获取值失败 - 键: " << key;
                            return jsi::Value::null();
                        }

                        std::string resultValue = value;
                        cursor->destroy(cursor);

                        DLOG(ERROR) << "123456789 getLocal完成 - 键: " << key << ", 值: " << resultValue;

                        return jsi::String::createFromUtf8(rt, resultValue);
                    }
                    catch (const std::exception &e)
                    {

                        throw jsi::JSError(rt, "getLocal failed: " + std::string(e.what()));
                    }
                });

            // 13. unsafeLoadFromSync方法
            auto unsafeLoadFromSyncFunc = jsi::Function::createFromHostFunction(
                rt,
                jsi::PropNameID::forAscii(rt, "unsafeLoadFromSync"),
                4,
                [](jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args, size_t count) -> jsi::Value
                {
                    if (count < 4)
                    {
                        throw jsi::JSError(rt, "unsafeLoadFromSync requires 4 arguments");
                    }

                    auto jsonId = (int)args[0].getNumber();
                    auto schema = args[1].getObject(rt);
                    std::string preamble = args[2].getString(rt).utf8(rt);
                    std::string postamble = args[3].getString(rt).utf8(rt);

                    DLOG(ERROR) << "123456789 unsafeLoadFromSync调用 - jsonId: " << jsonId;

                    try
                    {
                        std::lock_guard<std::mutex> lock(storeMutex);

                        // 检查数据库是否已初始化
                        if (!isDatabaseInitialized || globalStore == nullptr)
                        {
                            throw jsi::JSError(rt, "Database not initialized. Call initialize() first.");
                        }

                        // 开始事务
                        int beginResult = OH_Rdb_BeginTransaction(globalStore);
                        if (beginResult != RDB_OK)
                        {
                            throw jsi::JSError(rt, "Failed to begin transaction for sync loading");
                        }

                        bool success = true;
                        std::string errorMessage;

                        try
                        {
                            // 1. 执行前导SQL（preamble）
                            if (!preamble.empty())
                            {
                                DLOG(ERROR) << "123456789 执行前导SQL: " << preamble;
                                int result = OH_Rdb_ExecuteV2(globalStore, preamble.c_str(), nullptr, nullptr);
                                if (result != RDB_OK)
                                {
                                    throw std::runtime_error("Failed to execute preamble SQL, error code: " + std::to_string(result));
                                }
                            }

                            DLOG(ERROR) << "123456789 处理同步数据 - jsonId: " << jsonId;

                            // 2.获取数据
                            std::string tableName = "posts"; // 默认表名
                            if (schema.hasProperty(rt, "table"))
                            {
                                tableName = schema.getProperty(rt, "table").getString(rt).utf8(rt);
                            }
                            else if (schema.hasProperty(rt, "name"))
                            {
                                tableName = schema.getProperty(rt, "name").getString(rt).utf8(rt);
                            }
                            else if (schema.hasProperty(rt, "tableName"))
                            {
                                tableName = schema.getProperty(rt, "tableName").getString(rt).utf8(rt);
                            }

                            std::vector<std::string> sampleData = {
                                "INSERT OR REPLACE INTO " + tableName + " (id, title, body) VALUES ('sync1', '同步标题1', '同步内容1')",
                                "INSERT OR REPLACE INTO " + tableName + " (id, title, body) VALUES ('sync2', '同步标题2', '同步内容2')",
                                "INSERT OR REPLACE INTO " + tableName + " (id, title, body) VALUES ('sync3', '同步标题3', '同步内容3')"};

                            // 3.同步数据
                            for (const auto &sql : sampleData)
                            {
                                DLOG(ERROR) << "123456789 执行插入SQL: " << sql;
                                int result = OH_Rdb_ExecuteV2(globalStore, sql.c_str(), nullptr, nullptr);
                                if (result != RDB_OK)
                                {
                                    throw std::runtime_error("Failed to insert sync data, error code: " + std::to_string(result));
                                }
                            }

                            // 4. 执行后置SQL（postamble）
                            if (!postamble.empty())
                            {
                                DLOG(ERROR) << "123456789 执行后置SQL: " << postamble;
                                int result = OH_Rdb_ExecuteV2(globalStore, postamble.c_str(), nullptr, nullptr);
                                if (result != RDB_OK)
                                {
                                    throw std::runtime_error("Failed to execute postamble SQL, error code: " + std::to_string(result));
                                }
                            }

                            success = true;
                        }
                        catch (const std::exception &e)
                        {
                            success = false;
                            errorMessage = e.what();
                        }

                        // 根据执行结果提交或回滚事务
                        if (success)
                        {
                            int commitResult = OH_Rdb_Commit(globalStore);
                            if (commitResult != RDB_OK)
                            {
                                OH_Rdb_RollBack(globalStore);
                                throw jsi::JSError(rt, "Failed to commit transaction for sync loading");
                            }
                            DLOG(ERROR) << "123456789 unsafeLoadFromSync完成";
                            return jsi::Value::null();
                        }
                        else
                        {
                            int rollbackResult = OH_Rdb_RollBack(globalStore);
                            if (rollbackResult != RDB_OK)
                            {
                                DLOG(ERROR) << "123456789 回滚事务失败";
                            }
                            throw jsi::JSError(rt, "unsafeLoadFromSync failed: " + errorMessage);
                        }
                    }
                    catch (const std::exception &e)
                    {
                        // 确保在异常情况下回滚事务
                        OH_Rdb_RollBack(globalStore);
                        throw jsi::JSError(rt, "unsafeLoadFromSync failed: " + std::string(e.what()));
                    }
                });

            // 14. unsafeExecuteMultiple方法
            auto unsafeExecuteMultipleFunc = jsi::Function::createFromHostFunction(
                rt,
                jsi::PropNameID::forAscii(rt, "unsafeExecuteMultiple"),
                1,
                [](jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args, size_t count) -> jsi::Value
                {
                    if (count < 1)
                    {
                        throw jsi::JSError(rt, "unsafeExecuteMultiple requires 1 argument");
                    }

                    auto sqlString = args[0].getString(rt).utf8(rt);

                    DLOG(ERROR) << "123456789 unsafeExecuteMultiple调用 - SQL长度: " << sqlString.length();

                    try
                    {
                        std::lock_guard<std::mutex> lock(storeMutex);

                        // 检查数据库是否已初始化
                        if (!isDatabaseInitialized || globalStore == nullptr)
                        {
                            throw jsi::JSError(rt, "Database not initialized. Call initialize() first.");
                        }

                        // 开始事务
                        int beginResult = OH_Rdb_BeginTransaction(globalStore);
                        if (beginResult != RDB_OK)
                        {
                            throw jsi::JSError(rt, "Failed to begin transaction for multiple SQL execution");
                        }

                        bool success = true;
                        std::string errorMessage;

                        try
                        {
                            // 按分号分隔SQL语句
                            std::vector<std::string> sqlStatements;
                            std::string currentStatement;
                            bool inQuotes = false;
                            char quoteChar = '\0';

                            for (size_t i = 0; i < sqlString.length(); i++)
                            {
                                char c = sqlString[i];

                                // 处理引号内的内容
                                if (c == '\'' || c == '\"')
                                {
                                    if (!inQuotes)
                                    {
                                        inQuotes = true;
                                        quoteChar = c;
                                    }
                                    else if (c == quoteChar)
                                    {
                                        inQuotes = false;
                                    }
                                }

                                // 不在引号内且遇到分号时，分隔语句
                                if (!inQuotes && c == ';')
                                {
                                    // 去除前后空白字符
                                    size_t start = currentStatement.find_first_not_of(" \t\n\r");
                                    size_t end = currentStatement.find_last_not_of(" \t\n\r");

                                    if (start != std::string::npos && end != std::string::npos)
                                    {
                                        std::string trimmed = currentStatement.substr(start, end - start + 1);
                                        if (!trimmed.empty())
                                        {
                                            sqlStatements.push_back(trimmed);
                                        }
                                    }
                                    currentStatement.clear();
                                }
                                else
                                {
                                    currentStatement += c;
                                }
                            }

                            // 处理最后一个语句（如果没有以分号结尾）
                            if (!currentStatement.empty())
                            {
                                size_t start = currentStatement.find_first_not_of(" \t\n\r");
                                size_t end = currentStatement.find_last_not_of(" \t\n\r");

                                if (start != std::string::npos && end != std::string::npos)
                                {
                                    std::string trimmed = currentStatement.substr(start, end - start + 1);
                                    if (!trimmed.empty())
                                    {
                                        sqlStatements.push_back(trimmed);
                                    }
                                }
                            }

                            DLOG(ERROR) << "123456789 解析出 " << sqlStatements.size() << " 个SQL语句";

                            // 逐个执行SQL语句
                            for (size_t i = 0; i < sqlStatements.size(); i++)
                            {
                                const auto &sql = sqlStatements[i];
                                DLOG(ERROR) << "123456789 正在执行第 " << (i + 1) << " 个SQL: " << sql;

                                int execResult = OH_Rdb_ExecuteV2(globalStore, sql.c_str(), nullptr, nullptr);
                                if (execResult != RDB_OK)
                                {
                                    success = false;
                                    errorMessage = "Execute failed for SQL #" + std::to_string(i + 1) + ": " + sql + ", error code: " + std::to_string(execResult);
                                    break;
                                }
                            }
                        }
                        catch (const std::exception &e)
                        {
                            success = false;
                            errorMessage = "SQL parsing failed: " + std::string(e.what());
                        }

                        // 根据执行结果提交或回滚事务
                        if (success)
                        {
                            int commitResult = OH_Rdb_Commit(globalStore);
                            if (commitResult != RDB_OK)
                            {
                                OH_Rdb_RollBack(globalStore);
                                throw jsi::JSError(rt, "Failed to commit transaction for multiple SQL execution");
                            }
                            DLOG(ERROR) << "123456789 unsafeExecuteMultiple完成 - 成功执行所有SQL语句";
                            return jsi::Value::undefined();
                        }
                        else
                        {
                            int rollbackResult = OH_Rdb_RollBack(globalStore);
                            if (rollbackResult != RDB_OK)
                            {
                                DLOG(ERROR) << "123456789 回滚事务失败";
                            }
                            throw jsi::JSError(rt, "unsafeExecuteMultiple failed: " + errorMessage);
                        }
                    }
                    catch (const std::exception &e)
                    {
                        // 确保在异常情况下回滚事务
                        OH_Rdb_RollBack(globalStore);
                        throw jsi::JSError(rt, "unsafeExecuteMultiple failed: " + std::string(e.what()));
                    }
                });

            // 15. setLocal方法
            auto setLocalFunc = jsi::Function::createFromHostFunction(
                rt,
                jsi::PropNameID::forAscii(rt, "setLocal"),
                2,
                [](jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args, size_t count) -> jsi::Value
                {
                    if (count < 2)
                    {
                        throw jsi::JSError(rt, "setLocal requires 2 arguments");
                    }

                    std::string key = args[0].getString(rt).utf8(rt);
                    std::string value = args[1].getString(rt).utf8(rt);

                    DLOG(ERROR) << "123456789 setLocal调用 - 键: " << key;

                    try
                    {
                        std::lock_guard<std::mutex> lock(storeMutex);

                        // 检查数据库是否已初始化
                        if (!isDatabaseInitialized || globalStore == nullptr)
                        {
                            throw jsi::JSError(rt, "Database not initialized. Call initialize() first.");
                        }

                        // 确保local_storage表存在
                        std::string createTableSql = "CREATE TABLE IF NOT EXISTS local_storage (key TEXT PRIMARY KEY, value TEXT)";
                        int createResult = OH_Rdb_ExecuteV2(globalStore, createTableSql.c_str(), nullptr, nullptr);
                        if (createResult != RDB_OK)
                        {
                            DLOG(ERROR) << "123456789 创建local_storage表失败: " << createResult;
                        }

                        // 插入或更新local_storage表
                        std::string sql = "INSERT OR REPLACE INTO local_storage (key, value) VALUES ('" + key + "', '" + value + "')";
                        int execResult = OH_Rdb_ExecuteV2(globalStore, sql.c_str(), nullptr, nullptr);

                        if (execResult != RDB_OK)
                        {
                            throw jsi::JSError(rt, "setLocal failed with error code: " + std::to_string(execResult));
                        }

                        DLOG(ERROR) << "123456789 setLocal完成 - 键: " << key;
                        return jsi::Value::undefined();
                    }
                    catch (const std::exception &e)
                    {
                        throw jsi::JSError(rt, "setLocal failed: " + std::string(e.what()));
                    }
                });

            // 16. removeLocal方法
            auto removeLocalFunc = jsi::Function::createFromHostFunction(
                rt,
                jsi::PropNameID::forAscii(rt, "removeLocal"),
                1,
                [](jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args, size_t count) -> jsi::Value
                {
                    if (count < 1)
                    {
                        throw jsi::JSError(rt, "removeLocal requires 1 argument");
                    }

                    std::string key = args[0].getString(rt).utf8(rt);

                    DLOG(ERROR) << "123456789 removeLocal调用 - 键: " << key;

                    try
                    {
                        std::lock_guard<std::mutex> lock(storeMutex);

                        // 检查数据库是否已初始化
                        if (!isDatabaseInitialized || globalStore == nullptr)
                        {
                            throw jsi::JSError(rt, "Database not initialized. Call initialize() first.");
                        }

                        // 确保local_storage表存在
                        std::string createTableSql = "CREATE TABLE IF NOT EXISTS local_storage (key TEXT PRIMARY KEY, value TEXT)";
                        int createResult = OH_Rdb_ExecuteV2(globalStore, createTableSql.c_str(), nullptr, nullptr);
                        if (createResult != RDB_OK)
                        {
                            DLOG(ERROR) << "123456789 创建local_storage表失败: " << createResult;
                        }

                        // 从local_storage表删除
                        std::string sql = "DELETE FROM local_storage WHERE key = '" + key + "'";
                        int execResult = OH_Rdb_ExecuteV2(globalStore, sql.c_str(), nullptr, nullptr);

                        if (execResult != RDB_OK)
                        {
                            throw jsi::JSError(rt, "removeLocal failed with error code: " + std::to_string(execResult));
                        }

                        DLOG(ERROR) << "123456789 removeLocal完成 - 键: " << key;
                        return jsi::Value::undefined();
                    }
                    catch (const std::exception &e)
                    {
                        throw jsi::JSError(rt, "removeLocal failed: " + std::string(e.what()));
                    }
                });

            // 17. unsafeResetDatabase方法
            auto unsafeResetDatabaseFunc = jsi::Function::createFromHostFunction(
                rt,
                jsi::PropNameID::forAscii(rt, "unsafeResetDatabase"),
                0,
                [](jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args, size_t count) -> jsi::Value
                {
                    DLOG(ERROR) << "123456789 unsafeResetDatabase调用 - 数据库重置";
                    try
                    {
                        std::lock_guard<std::mutex> lock(storeMutex);

                        // 检查数据库是否已初始化
                        if (!isDatabaseInitialized || globalStore == nullptr)
                        {
                            throw jsi::JSError(rt, "Database not initialized. Call initialize() first.");
                        }

                        // 开始事务
                        int beginResult = OH_Rdb_BeginTransaction(globalStore);
                        if (beginResult != RDB_OK)
                        {
                            throw jsi::JSError(rt, "Failed to begin transaction for database reset");
                        }

                        bool transactionSuccess = false;
                        try
                        {
                            // 动态获取所有用户表并删除
                            // 查询sqlite_master获取所有用户表
                            std::string getTablesSql = "SELECT name FROM sqlite_master WHERE type='table' AND name NOT LIKE 'sqlite_%'";
                            OH_Cursor *cursor = OH_Rdb_ExecuteQueryV2(globalStore, getTablesSql.c_str(), nullptr);

                            if (cursor != nullptr)
                            {
                                // 遍历所有表并删除
                                while (cursor->goToNextRow(cursor) == RDB_OK)
                                {
                                    char tableName[256];
                                    int nameLength = 0;
                                    // 修复：传递变量本身，而不是地址
                                    if (cursor->getText(cursor, 0, tableName, nameLength) == RDB_OK)
                                    {
                                        std::string table(tableName);
                                        if (table != "android_metadata") // 排除系统表
                                        {
                                            std::string dropSql = "DROP TABLE IF EXISTS " + table;
                                            int dropResult = OH_Rdb_ExecuteV2(globalStore, dropSql.c_str(), nullptr, nullptr);
                                            if (dropResult != RDB_OK)
                                            {
                                                DLOG(ERROR) << "123456789 删除表失败: " << table;
                                            }
                                            else
                                            {
                                                DLOG(ERROR) << "123456789 删除表: " << table;
                                            }
                                        }
                                    }
                                }
                                cursor->destroy(cursor);
                            }
                            else
                            {
                                // 如果无法查询表，使用预定义的表列表
                                std::vector<std::string> predefinedTables = {"local_storage", "sync_metadata", "changes", "movies"};
                                for (const auto &table : predefinedTables)
                                {
                                    std::string dropSql = "DROP TABLE IF EXISTS " + table;
                                    int dropResult = OH_Rdb_ExecuteV2(globalStore, dropSql.c_str(), nullptr, nullptr);
                                    if (dropResult != RDB_OK)
                                    {
                                        DLOG(ERROR) << "123456789 删除预定义表失败: " << table;
                                    }
                                    else
                                    {
                                        DLOG(ERROR) << "123456789 删除预定义表: " << table;
                                    }
                                }
                            }

                            // 清理WAL文件（如果支持）
                            // 执行VACUUM清理数据库空间
                            std::string vacuumSql = "VACUUM";
                            int vacuumResult = OH_Rdb_ExecuteV2(globalStore, vacuumSql.c_str(), nullptr, nullptr);
                            if (vacuumResult != RDB_OK)
                            {
                                DLOG(ERROR) << "123456789 VACUUM操作失败";
                            }

                            // 提交事务
                            int commitResult = OH_Rdb_Commit(globalStore);
                            if (commitResult != RDB_OK)
                            {
                                throw jsi::JSError(rt, "Failed to commit transaction for database reset");
                            }

                            transactionSuccess = true;
                            DLOG(ERROR) << "123456789 数据库重置完成";
                        }
                        catch (const std::exception &e)
                        {
                            // 回滚事务
                            OH_Rdb_RollBack(globalStore);
                            throw;
                        }

                        if (!transactionSuccess)
                        {
                            // 确保事务回滚
                            OH_Rdb_RollBack(globalStore);
                        }

                        return jsi::Value::undefined();
                    }
                    catch (const std::exception &e)
                    {
                        throw jsi::JSError(rt, "unsafeResetDatabase failed: " + std::string(e.what()));
                    }
                });

            // 将所有方法设置到适配器对象上
            adapter.setProperty(rt, "initialize", std::move(initializeFunc));
            adapter.setProperty(rt, "setUpWithSchema", std::move(setUpWithSchemaFunc));
            adapter.setProperty(rt, "setUpWithMigrations", std::move(setUpWithMigrationsFunc));
            adapter.setProperty(rt, "find", std::move(findFunc));
            adapter.setProperty(rt, "query", std::move(queryFunc));
            adapter.setProperty(rt, "queryAsArray", std::move(queryAsArrayFunc));
            adapter.setProperty(rt, "queryIds", std::move(queryIdsFunc));
            adapter.setProperty(rt, "unsafeQueryRaw", std::move(unsafeQueryRawFunc));
            adapter.setProperty(rt, "count", std::move(countFunc));
            adapter.setProperty(rt, "batch", std::move(batchFunc));
            adapter.setProperty(rt, "batchJSON", std::move(batchJSONFunc));
            adapter.setProperty(rt, "getLocal", std::move(getLocalFunc));
            adapter.setProperty(rt, "unsafeLoadFromSync", std::move(unsafeLoadFromSyncFunc));
            adapter.setProperty(rt, "unsafeExecuteMultiple", std::move(unsafeExecuteMultipleFunc));
            adapter.setProperty(rt, "setLocal", std::move(setLocalFunc));
            adapter.setProperty(rt, "removeLocal", std::move(removeLocalFunc));
            adapter.setProperty(rt, "unsafeResetDatabase", std::move(unsafeResetDatabaseFunc));

            return adapter;
        });

    globalObject.setProperty(rt, "nativeWatermelonCreateAdapter", std::move(createAdapterFunc));

    DLOG(ERROR) << "123456789 JSI初始化完成";
}
